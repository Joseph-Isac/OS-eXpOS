
[PROCESS_TABLE + 16*[SYSTEM_STATUS_TABLE+1] + 13] = SP;
SP = 512 * [PROCESS_TABLE + (16 * [SYSTEM_STATUS_TABLE+1]) + 11] + [PROCESS_TABLE + 16*[SYSTEM_STATUS_TABLE+1] + 12];

backup;

if ([SYSTEM_STATUS_TABLE+5]!=0) then
	if ([SYSTEM_STATUS_TABLE+1]==SWAPPER_DAEMON) then
		if ([SYSTEM_STATUS_TABLE+5]==SWAP_OUT) then
			R1=1;
			R2=[SYSTEM_STATUS_TABLE+1];		
			call PAGER_MODULE;
		else
			R1=2;
			R2=[SYSTEM_STATUS_TABLE+1];
			call PAGER_MODULE;
		endif;
	endif;
else
	if ([SYSTEM_STATUS_TABLE+2]<MEM_LOW) then
		[SYSTEM_STATUS_TABLE+5]=SWAP_OUT;
	else
		if ([SYSTEM_STATUS_TABLE+4]>0) then
			R1=3;
			while (R1<15) do
				if ([PROCESS_TABLE+16*R1+6]==1 && [PROCESS_TABLE+16*R1+4]==READY && [PROCESS_TABLE+16*R1+0]>MAX_TICK) then
					[SYSTEM_STATUS_TABLE+5]=SWAP_IN;
					break;
				endif;
				R1=R1+1;
			endwhile;

			if ([SYSTEM_STATUS_TABLE+2]>MEM_HIGH) then
				[SYSTEM_STATUS_TABLE+5]=SWAP_IN;
			endif;
		endif;
	endif;
endif;
				
[PROCESS_TABLE + 16*[SYSTEM_STATUS_TABLE+1] + 4] = READY;

R1=0;
while (R1<16) do
	if ([PROCESS_TABLE+16*R1+4]!=TERMINATED) then
		[PROCESS_TABLE+16*R1+0]=[PROCESS_TABLE+16*R1+0]+1;
	endif;
	R1=R1+1;
endwhile;

call SCHEDULER;

//if the new_pid had ready state
restore;
[PROCESS_TABLE + 16*[SYSTEM_STATUS_TABLE+1] + 12] = SP%512;

SP = [PROCESS_TABLE + 16*[SYSTEM_STATUS_TABLE+1] + 13];
[PROCESS_TABLE + 16*[SYSTEM_STATUS_TABLE+1] + 9]= 0;

ireturn;
